# ğŸ“ Member C - Presentation Guide
**Your Assignment: System & Settings Owner**  
**Skill Level: Foundation Building (You'll master the basics!)**

---

## ğŸ¯ Your Feature Slice
- **User Authentication** (Login/Register)
- **User Model** (MongoDB Schema)
- **Settings Model** (MongoDB Schema)
- **Global Layout/Navigation** (React Context & Protected Routes)
- **Settings Page Logic** (Frontend-Backend Integration)

**Key Concept:** "Session Management & Persistence"


---

## 1. The "Full Stack Flow" Study Guide

### ğŸ” **Authentication Flow (Register/Login)**

#### **Backend (MongoDB â†’ Express):**

**Register Flow:**
```
1. User submits form â†’ POST /api/auth/register
   â†“
2. Express Route (authRoutes.js) â†’ authController.register()
   â†“
3. Validation: Check if email already exists
   - User.findOne({ email }) â†’ MongoDB Query
   â†“
4. Password Hashing: bcrypt.genSalt(10) + bcrypt.hash()
   - Security: Never store plain passwords
   â†“
5. Create User: User.create({ name, email, passwordHash })
   - MongoDB Insert â†’ users collection
   â†“
6. Generate JWT Token: generateToken(user._id)
   - Uses jsonwebtoken library
   â†“
7. Response: { user: {id, name, email}, token }
```

**Login Flow:**
```
1. User submits credentials â†’ POST /api/auth/login
   â†“
2. Express Route â†’ authController.login()
   â†“
3. Find User: User.findOne({ email }) â†’ MongoDB Query
   â†“
4. Verify Password: bcrypt.compare(password, user.passwordHash)
   - Returns true/false
   â†“
5. Generate JWT Token (same as register)
   â†“
6. Response: { user, token }
```

#### **Frontend (React):**

**AuthContext (State Management):**
```
1. Token Storage: localStorage.getItem("token")
   - Persists across page refreshes
   â†“
2. useEffect Hook: Auto-fetch user on mount
   - GET /api/auth/me (if token exists)
   - Sets user state if valid
   â†“
3. Login Function: 
   - api.post("/auth/login") â†’ Receives { user, token }
   - setToken(token) â†’ Updates state
   - localStorage.setItem("token", token) â†’ Persists
   â†“
4. Protected Routes: <ProtectedRoute />
   - Checks if user exists
   - Redirects to /login if not authenticated
```

**Data Flow Diagram:**
```
React Form (LoginPage.jsx)
  â†“ onSubmit â†’ login(email, password)
AuthContext.login()
  â†“ POST /api/auth/login
Express authController.login()
  â†“ User.findOne() + bcrypt.compare()
MongoDB users collection
  â†“ Returns user document
JWT Token Generated
  â†“ Response: { user, token }
AuthContext: setToken() + localStorage
  â†“ State updated
ProtectedRoute allows access
  â†“ User sees Dashboard
```

---

### âš™ï¸ **Settings Flow (Get/Update)**

#### **Backend (MongoDB â†’ Express):**

**Get Settings:**
```
1. Frontend Request: GET /api/settings
   â†“
2. authMiddleware: Validates JWT token
   - Extracts userId from token
   â†“
3. settingsController.getSettings()
   â†“
4. MongoDB Query: Settings.findOne({ userId: req.user._id })
   â†“
5. Auto-Creation Logic:
   - If no settings exist â†’ Settings.create({ userId, energyLimit: 15, waterLimit: 100 })
   - Ensures every user has settings
   â†“
6. Response: { energyLimit, waterLimit }
```

**Update Settings:**
```
1. Frontend Request: PATCH /api/settings
   Body: { energyLimit: 20, waterLimit: 150 }
   â†“
2. authMiddleware: Validates JWT
   â†“
3. settingsController.updateSettings()
   â†“
4. Validation: Check min/max constraints
   - energyLimit: 5-50 kWh
   - waterLimit: 50-200 L
   â†“
5. MongoDB Query: Settings.findOne({ userId })
   â†“
6. Update or Create:
   - If exists: settings.energyLimit = value â†’ settings.save()
   - If not: Settings.create()
   â†“
7. Response: Updated { energyLimit, waterLimit }
```

#### **Frontend (React):**

**Settings Page Integration:**
```
1. Component Mount: useEffect()
   â†“
2. Fetch Settings: api.get("/settings")
   â†“
3. Update State: setLimits({ energy, water })
   â†“
4. User Drags Slider: onChange â†’ updateLimits() (instant UI)
   â†“
5. User Releases Slider: onMouseUp â†’ saveSettings()
   â†“
6. API Call: api.patch("/settings", { energyLimit: value })
   â†“
7. MongoDB Updated: Settings document saved
   â†“
8. State Already Updated (optimistic update)
```

**Data Persistence:**
```
User Changes Slider
  â†“ Local State Updates (instant feedback)
User Releases Mouse
  â†“ PATCH /api/settings
MongoDB Settings Collection
  â†“ Document Updated
Refresh Page
  â†“ GET /api/settings
MongoDB Returns Saved Values
  â†“ Slider Shows Previous Position
```

---

### ğŸ—„ï¸ **Database Schema (MongoDB Models)**

**User Model:**
```javascript
{
  name: String (required, trimmed)
  email: String (required, unique, lowercase)
  passwordHash: String (required, bcrypt hashed)
  role: String (enum: 'user'/'admin', default: 'user')
  timestamps: createdAt, updatedAt (auto)
}
```

**Settings Model:**
```javascript
{
  userId: ObjectId (required, unique, ref: 'User')
  energyLimit: Number (default: 15, min: 5, max: 50)
  waterLimit: Number (default: 100, min: 50, max: 200)
  timestamps: createdAt, updatedAt (auto)
}
```

**Key Relationships:**
- Settings.userId â†’ User._id (One-to-One relationship)
- Unique index on userId ensures one settings per user

---

## 2. 3 Technical Keywords (Must Use)

1. **JWT (JSON Web Token)**
   - "I implemented JWT-based authentication for stateless session management. The token is stored in localStorage and sent in the Authorization header for protected routes."

2. **bcrypt Hashing**
   - "Passwords are secured using bcrypt with a salt factor of 10, ensuring one-way encryption. The passwordHash is stored in MongoDB, never the plain password."

3. **Optimistic UI Updates**
   - "The settings sliders use optimistic updates - the UI responds instantly to user input, while the backend persistence happens asynchronously on slider release."

---

## 3. The Viva Presentation Script

> "I was responsible for the **authentication and session management architecture** of our Full Stack application. I implemented the complete user authentication system using JWT tokens, which includes user registration and login flows with bcrypt password hashing for security. Additionally, I developed the Settings model with a one-to-one relationship to users, implementing auto-creation logic so every authenticated user automatically gets default settings. The frontend uses React Context API for global state management, ensuring the user session persists across page refreshes through localStorage. The settings page demonstrates real-time synchronization between the React state and MongoDB, with optimistic UI updates for immediate user feedback."

---

## 4. A "Tough Question" & Answer

**Question:** "Why did you use JWT tokens instead of session-based authentication? What happens if a user's token is stolen?"

**Answer:**
> "We chose JWT tokens for **stateless authentication**, which is ideal for RESTful APIs and allows horizontal scaling without shared session storage. The token contains the user ID in its payload, which is verified on each request using a secret key. If a token is stolen, we have implemented token expiration (typically 7 days), and the token is stored in localStorage with HTTP-only cookies as a potential enhancement. For production, we would add token refresh mechanisms and implement token blacklisting. The current implementation also validates the token on every protected route through our authMiddleware, which extracts and verifies the JWT before allowing access to the MongoDB queries."

---

## ğŸ“š Your File Locations (Study These!)

### **Backend Files:**
- `server/src/models/User.js` - User schema definition
- `server/src/models/Settings.js` - Settings schema definition
- `server/src/controllers/authController.js` - Register/login logic
- `server/src/controllers/settingsController.js` - Settings CRUD logic
- `server/src/middleware/authMiddleware.js` - JWT validation

### **Frontend Files:**
- `client/client/src/context/AuthContext.jsx` - Global auth state
- `client/client/src/pages/LoginPage.jsx` - Login form
- `client/client/src/pages/RegisterPage.jsx` - Registration form
- `client/client/src/components/ProtectedRoute.jsx` - Route protection

---

## ğŸ’¡ Study Tips for You

1. **Start with the Flow Diagrams** - Understand how data moves from React â†’ Express â†’ MongoDB
2. **Practice the Script** - Read it out loud 5 times before the presentation
3. **Know Your Keywords** - JWT, bcrypt, Optimistic Updates - use them naturally
4. **Understand the "Why"** - Not just what you did, but why you chose JWT over sessions

---

**You've got this! Your slice is foundational - master it and you'll impress! ğŸš€**

